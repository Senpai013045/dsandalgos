<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@10.5.0/styles/monokai.css"
    />

    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h1 class="heading__primary">
          Course notes for Data Structures and algorithms
        </h1>
      </header>
      <main class="main">
        <p class="text">
          Hello there, thanks for checking this page. I know this isn't complete
          but it's something i'll be adding on as I progress throught the vast
          ocean of Data Structures and Algorithms. Also please check the console
          for code results and if you wanna test the code, the functions are
          globally available.
        </p>
        <section class="section">
          <h2 class="heading__secondary">Frequency Counter Pattern</h2>
          <p class="text">
            Create a function named "same" that takes two arrays as arguments
            and checks if the values on the second array is squared of the
            values of the first array. Now, the first thing that comes to our
            mind would be to use a nested loop and immediately sabotage the Big
            O by producing a code that's O(nÂ²) in time complexity. The better
            approach would be to use objects in a smart way and avoid nested
            loops. Multiple loops are performance efficient than nested ones.
          </p>
          <pre class="code">
            /*
same([1,2,3],[4,1,9]) must be true
same([1,2,3],[1,8]) must be false
same([1,2,1],[4,4,1]) must be false
*/

function same(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  const obj1 = {};
  const obj2 = {};

  arr1.forEach((item) => {
    obj1[item] = obj1[item] + 1 || 1;
  });

  arr2.forEach((item) => {
    obj2[item] = (obj2[item] || 0) + 1;
  });

  console.log("obj1 >", obj1);
  console.log("obj2 >", obj2);

  //check if the frequency of keys are same
  let accumulator = true;
  for (const key in obj1) {
    accumulator =
      accumulator && key ** 2 in obj2 && obj1[key] === obj2[key ** 2];
  }
  return accumulator;
}

console.log("Frequency counter pattern log: ", same([9], [81, 81]));
          </pre>
          <p class="text">
            The approach we took in the code above can also be useful in other
            similar problems like the famous "Anagram" pattern. The problem
            involves finding if 2 strings are anagram of each other ie.
            rearranged characters of same word. Example: "iceman" is an anagram
            of "cinema". For the simplicity's sake we're going to assume that
            both arguments are lower case words with no whitepsace in between.
          </p>
          <pre class="code">
function validAnagram(string1, string2) {
  if (string1.length !== string1.length) {
    return false;
  }

  const obj1 = {};
  const obj2 = {};

  for (const character of string1) {
    obj1[character] = (obj1[character] || 0) + 1;
  }

  for (const character of string2) {
    obj2[character] = (obj2[character] || 0) + 1;
  }

  for (const character in obj1) {
    if (obj1[character] !== obj2[character]) {
      return false;
    }
  }
  return true;
}

console.log("anagram function log: ", validAnagram("cinema", "iceman"));
            
          </pre>
        </section>
        <section class="section">
          <h2 class="heading__secondary mb1">Multiple Pointers Pattern</h2>
          <p class="text">
            Write a function that takes in a sorted array of numbers and returns
            the first pair that sums to zero. Example: [-2,0,1,2] should return
            [-2,2]
          </p>
          <pre class="code">
function findThePairThatSumsToZero(arr) {
  let leftPointer = 0;
  let rightPointer = arr.length - 1;

  while (leftPointer < rightPointer) {
    let sum = arr[leftPointer] + arr[rightPointer];
    if (sum === 0) {
      return [arr[leftPointer], arr[rightPointer]];
    } else if (sum > 0) {
      rightPointer--;
    } else {
      leftPointer++;
    }
  }
}

console.log(
  "Found the pair that sums to zero: ",
  findThePairThatSumsToZero([-5, 1, 2, 3, 4, 5, 6, 7, 8])
          </pre>
          <p class="text">
            The same pattern can be used to find the number of unique values in
            an array. Keep in mind this will only work on a sorted array.
          </p>
          <pre class="code">
function countUniqueValuesInThisArray(arr) {
  if (arr.length === 0) {
    return 0;
  }
  if (arr.length === 1) {
    return 1;
  }
  let leftPointer = 0;
  for (let rightPointer = 1; rightPointer < arr.length; rightPointer++) {
    if (arr[leftPointer] !== arr[rightPointer]) {
      leftPointer++;
      arr[leftPointer] = arr[rightPointer];
    }
  }
  return leftPointer + 1; //cause index starts at zero
}

console.log(
  "The number of unique values in this array is: ",
  countUniqueValuesInThisArray([1, 2, 2, 2, 2, 3, 3, 3])
);
          </pre>
        </section>
        <section class="section">
          <h2 class="heading__secondary">Sliding window pattern</h2>
          <p class="text">
            This pattern involves creating a window which can either be an array
            or number from one position to another Depending on a certain
            condition, the window either increases or closes (and a new window
            is created) Very useful for keeping track of a subset of data in an
            array/string etc.
          </p>
          <p class="text">
            Consider the problem: Write a function called maxSubarraySum which
            accepts an array of integers and a number called n. The function
            should calculate the maximum sum of n consecutive elements in the
            array.
          </p>
          <pre class="code">
/*
calculate the maxSubarraySum
maxSubarraySum([1,2,5,2,8,1,5],2) // 10
maxSubarraySum([1,2,5,2,8,1,5],4) // 17
maxSubarraySum([4,2,1,6],1) // 6
maxSubarraySum([4,2,1,6,2],4) // 13
maxSubarraySum([],4) // null
*/

function maxSubarraySum(numberArray, numberOfConsecutiveValues) {
  //edge case first
  if (numberOfConsecutiveValues > numberArray.length) {
    return null;
  }

  let maximumSum = 0;
  let temporarySum = 0;

  for (let i = 0; i < numberOfConsecutiveValues; i++) {
    /*i is less than numberOfConsecutiveValue cause array are 0 indexed*/
    temporarySum += numberArray[i];
  }
  maximumSum = temporarySum;

  for (let i = numberOfConsecutiveValues; i < numberArray.length; i++) {
    temporarySum =
      temporarySum +
      numberArray[i] -
      numberArray[i - numberOfConsecutiveValues];
    maximumSum = Math.max(temporarySum, maximumSum);
  }
  return maximumSum;
}

console.log(
  "The largest consecutive sum log: ",
  maxSubarraySum([1, 8, 1, 2, 3, 5, 2, 0], 2)
);



          </pre>
          <p class="text">
            After immediately getting rid of edge case scenario, we have 2
            placeholder, maximumSum and temporarySum. The first for loop will
            run one less times the number of Consecutive values required cause
            arrays are zero indexed, resulting is running twice when 3 is
            specified which is exactly what we want. We add all the values up to
            that index in the temporary variable. We then assign maxumumSum to
            be the temporarySum and run the loop again, but this time our
            starting index will be the specified consecutive count. We now
            subtract the value before the current item and add value that's
            after the item and check for largest among temporary and maximum
            sum. We return the maximum sum at the end.
          </p>
        </section>
        <section class="section">
          <h2 class="heading__secondary">Recursion</h2>
          <p class="text">
            A recursive function is a function that calls itself. In javascript,
            function calls are handled by a callstack which pushes and pops the
            most recent function from the stack. If a function relies on a
            function inside it. The callstack will put the previous function at
            the bottom of the stack and keep pushing every function whose values
            are relied on top of it. Once all the dependency(functions) are
            returned the initial function can now resolve. Recursive functions
            are different as it keeps calling itself unless a certain criterea
            is met. So the important thing to have in a recursive function are :
            a base case exit the function, and having the same function call
            itself with different input.
          </p>
          <pre class="code">
function addAllNumbersBetweenOneTo(n) {
  if (n === 1) return 1;
  return n + addAllNumbersBetweenOneTo(n - 1);
}

console.log(
  "The sum of all numbers between 1 to 5 is",
  addAllNumbersBetweenOneTo(5)
);

//visual explainination
/*
addAllNumbersBetweenOneTo(5)

is 5 equal to 1? no so keep going

return 5 + addAllNumbersBetweenOneTo(4)

is 4 equal to 1? no so keep going

return 4 + addAllNumbersBetweenOneTo(3)

is 3 equal to 1? no so keep going

return 3 + addAllNumbersBetweenOneTo(2)

is 2 equal to 1? no so keep going

return 2 + addAllNumbersBetweenOneTo(1)

is 1 equal to 1? Yes! so return 1

return 2 + 1

//lets see one simple example

we now know addAllNumbersBetweenOneTo(1) = 1

addAllNumbersBetweenOneTo(2)= 2 + addAllNumbersBetweenOneTo(2-1) 
                            = 2+1
                            = 3

addAllNumbersBetweenOneTo(3)= 3 + addAllNumbersBetweenOneTo(3-1) 
                            = 3 + addAllNumbersBetweenOneTo(2) 
                            = 3 + 3
                            = 6

//you can work your way upwards in this way
*/
            
          </pre>
          <p class="text">
            Lets write a factorial function using recursion. Lets look at a
            simple example first: factorial(5). This function will calculate
            5*4*3*2*1 , here 1 is our base case and each recursion deals with
            the factorial of given number - 1. Here's how that translates into
            code.
          </p>
          <pre class="code">
function recursiveFactorial(n) {
  //base case of 1
  if (n === 1) return 1;
  //changing input
  return n * recursiveFactorial(n - 1);
}

console.log(
  "Factorial of 5 using recursive function is: ",
  recursiveFactorial(5)
);
          </pre>
          <p class="text">
            The most important thing to go through while creating a recursive
            function is to have a base return and making sure your input keeps
            changing and will hit the base case. Else, you'll hit Stack Overflow
            as your function keeps going on.
          </p>
        </section>
      </main>
    </div>
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre.code").forEach((block) => {
          hljs.highlightBlock(block);
        });
      });
    </script>
    <script src="app.js"></script>
  </body>
</html>
